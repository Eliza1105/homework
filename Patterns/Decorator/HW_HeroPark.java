package Patterns.Decorator;
/*
Преимущества:1.Большая гибкость, чем у наследования.
2.Позволяет добавлять обязанности на лету.
3.Можно добавлять несколько новых обязанностей сразу.
4.Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.
Недостатки: 1.Трудно конфигурировать многократно обёрнутые объекты.
2.Обилие крошечных классов.

Взаимодействие с другими шаблонами:
-Адаптер предоставляет совершенно другой интерфейс для доступа к существующему объекту. С другой стороны, при использовании паттерна Декоратор интерфейс либо остается прежним, либо расширяется. Причём Декоратор поддерживает рекурсивную вложенность, чего не скажешь об Адаптере.
-С Адаптером вы получаете доступ к существующему объекту через другой интерфейс. Используя Заместитель, интерфейс остается неизменным. Используя Декоратор, вы получаете доступ к объекту через расширенный интерфейс.
-Цепочка обязанностей и Декоратор имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.
Обработчики в Цепочке обязанностей могут выполнять произвольные действия, независимые друг от друга, а также в любой момент прерывать дальнейшую передачу по цепочке. С другой стороны Декораторы расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.
-Компоновщик и Декоратор имеют похожие структуры классов из-за того, что оба построены на рекурсивной вложенности. Она позволяет связать в одну структуру бесконечное количество объектов.
Декоратор оборачивает только один объект, а узел Компоновщика может иметь много детей. Декоратор добавляет вложенному объекту новую функциональность, а Компоновщик не добавляет ничего нового, но «суммирует» результаты всех своих детей.
Но они могут и сотрудничать: Компоновщик может использовать Декоратор, чтобы переопределить функции отдельных частей дерева компонентов.
-Архитектура, построенная на Компоновщиках и Декораторах, часто может быть улучшена за счёт внедрения Прототипа. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.
-Стратегия меняет поведение объекта «изнутри», а Декоратор изменяет его «снаружи».
-Декоратор и Заместитель имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что Заместитель сам управляет жизнью сервисного объекта, а обёртывание Декораторов контролируется клиентом.
 */
//идея в раелизации различных опций детского центра.
public class HW_HeroPark {
    public static void main(String[] args) {
Options visiter = new Restroom(new Trampoline(new GameZone()));
        System.out.println(visiter.visitGameZone());
    }
}

 interface Options {
   public String visitGameZone();
}
class GameZone implements Options{

    @Override
    public String visitGameZone() {
        return "Посещение игровой зоны. ";
    }
}
class GameZoneDecorator implements Options{
    Options vister;

    public GameZoneDecorator(Options vister) {
        this.vister = vister;
    }

    @Override
    public String visitGameZone() {
        return vister.visitGameZone();
    }
}
class Trampoline extends GameZoneDecorator{
public  Trampoline(Options visiter){
    super(visiter);
}
public String visitTrampoline(){
    return "Посещение батутов. ";
}

    @Override
    public String visitGameZone() {
        return super.visitGameZone()+ visitTrampoline();
    }
}
class Restroom extends GameZoneDecorator{

    public Restroom(Options vister) {
        super(vister);
    }
    public String visitRestroom(){
        return "Посещение комнаты отдыха";
    }

    @Override
    public String visitGameZone() {
        return super.visitGameZone()+visitRestroom();
    }
}



